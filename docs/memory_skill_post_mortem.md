# AI 记忆与上下文持久化：复盘分析 (2026-01-17)

**文档目的**：记录关于 "AI 项目上下文 (Project Context)" 解决方案的调研、实验与发现，为未来的尝试提供基础。

## 1. 当前已具备的能力 (Existing Capabilities)
我们已经成功部署了 **"经验沉淀 (Knowledge Deposit)"** 技能：
- **功能**：当解决了一个具体的技术难题时，能够将 "问题 + 解决方案" 提炼成可复用的 `SKILL.md`。
- **状态**：**已上线且运行良好**。
- **局限**：它只关注 "点" (特定的知识/技巧)，无法覆盖 "面" (整个项目的开发进度、上下文、琐碎的修改历史)。
- **本次任务的关联**：本次尝试的 "项目上下文 (Project Context)" 本意是作为 "经验沉淀" 的补充，填补 "宏观记忆" 的空白。

## 2. 问题陈述 (Problem Statement)
尽管有了 "经验沉淀" 技能，但在与 AI 进行长期项目协作时，我们仍面临 "项目失忆 (Project Amnesia)" 问题：
- **上下文丢失**：每次新的会话都是一片空白。AI 忘记了之前的代码变更、架构决策和开发进度。
- **效率低下**：AI 每次都需要重新阅读所有代码才能 "跟上进度"，这导致 Token 消耗巨大且速度缓慢。
- **割裂感**：AI 感觉像是一个每天新来的员工，而不是一个了解项目历史的长期合作伙伴。

## 2. 预期结果 (Desired Result)
我们需要一个 "项目上下文管理器 (Project Context Manager)" 系统，它应该满足：
- **持久性**：自动记住跨会话的开发内容和讨论细节。
- **真实性**：保留 **原始未改动 (Raw, Verbatim)** 的对话记录（包括具体指令和用户意图），而不仅仅是容易丢失细节的 AI 摘要。
- **自动化**：在后台静默运行 (Zero-Touch)，不需要用户每次手动触发保存。
- **高效性**：无需重复生成/分析整个历史记录（避免 Token 爆炸）。

## 3. 尝试过的方案 (Solutions Attempted)

### 尝试 1：全局技能 + 本地状态文件
- **概念**：使用全局 `project-context-manager` 技能维护一个 `.agent/memory/project_status.md` 文件。
- **机制**：AI 将特定任务状态总结到结构化的 Markdown 文件中。
- **结果**：**失败**。总结过于宏观。它捕捉了 "是什么" (状态)，但丢失了 "怎么做" 和 "为什么" (原始对话上下文)。

### 尝试 2：全量上下文转录 (AI 生成)
- **概念**：AI 读取当前的上下文窗口并将其 "转录" 到文件中 (`write_to_file`)。
- **机制**：`当前上下文 -> AI 生成 -> 文件`。
- **结果**：**失败**。
  - **Token 成本**：写出完整的历史记录极其缓慢且昂贵。
  - **保真度**：即使有 "逐字 (verbatim)" 指令，AI 也会潜意识地 "修饰" 文本（修复语法、删除语气词），违反了原始记录的需求。

### 尝试 3：原生日志访问 (直接读取)
- **概念**：绕过 AI 生成，直接读取 IDE 内部的聊天日志或数据库 (`state.vscdb`, `leveldb`)。
- **机制**：使用 Shell 命令 (`grep`, `sqlite3`) 查找 `~/Library/Application Support/Antigravity` 数据。
- **结果**：**失败**。
  - **沙箱限制**：AI Agent 运行在沙箱中，无法可靠地访问宿主 IDE 的加密或驻留内存的数据库。
  - **无纯文本**：聊天记录并未以纯文本文件形式存储在硬盘上。

### 尝试 4：零操作增量追加 (Shell 动作)
- **概念**：在每次回复后，使用 Shell `cat >>` 命令将最后一轮对话追加到日志文件中。
- **机制**：通过 Skill 的系统提示词 (System Prompt) 自动化执行。
- **结果**：**失败**。
  - **用户体验**：感觉 "太慢" (阻塞了最终响应)。
  - **可靠性**：依赖模型严格遵循 "本能反应" 指令，表现不稳定。
  - **保真度**：仍然依赖模型 "输出" 用户提示词的文本，技术上讲这仍然是一次重新生成，而非真正的复制。

### 尝试 5：手动导出摄入 (折衷方案)
- **概念**：用户手动使用 IDE 的 "Export" 按钮；AI 只读取生成的文件。
- **机制**：被动 "只读 (Read-Only)" 模式。
- **结果**：**放弃**。用户正确地指出，这违背了 "自动化助手" 的初衷，操作摩擦太大。

## 4. 关键结论与未来方向 (Key Learnings & Future Direction)

**核心阻碍 (Core Blocker)**：
Agent **无法访问 IDE 真正的 "原始输入流 (Raw Input Stream)"**。它只能接收 *当前* 的上下文窗口。Agent 试图 "保存" 聊天的任何尝试，本质上都涉及 Agent *重新生成* 文本，这在本质上就是慢的（生成速度受限）且容易被篡改（模型对齐影响）。

**未来解决方案要求**：
要彻底解决这个问题，能力必须来自 **IDE 系统层**，而不是 **Agent 技能层**。
1.  **系统钩子 (System Hook)**：IDE 本身 (Antigravity) 需要暴露一个 "Chat Logger" API 或设置，自动将聊天保存到 `.agent/logs/`。
2.  **无生成 (No-Gen)**：保存必须是文件系统的复制操作，而不是 LLM 的生成任务。

---
*Created by Antigravity Agent, 2026-01-17*
